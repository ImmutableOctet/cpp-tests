// Used only for the demo portion.
#include <iostream>
#include <typeinfo>

// Needed for generated type-traits.
#include <type_traits>

/*
    This macro generates a type-trait template in `util::generated_impl` named `trait_name`
    for a function named `function_name` with the signature `function_signature`.
    
    `util::generated_impl::[`trait_name`]::value` then produces a boolean value,
    indicating whether the `InputType` has the `function_name` specified.
*/
#define GENERATE_STATIC_MEMBER_FUNCTION_CHECK_TRAIT(trait_name, function_name, function_signature)                                    \
    namespace util::generated_impl                                                                                                    \
    {                                                                                                                                 \
        template <typename InputType>                                                                                                 \
        class trait_name                                                                                                              \
        {                                                                                                                             \
            private:                                                                                                                  \
                template<typename T, T> struct type_and_signature;                                                                    \
                template<typename T> static std::true_type  has_function(type_and_signature<function_signature, &T::function_name>*); \
                template<typename T> static std::false_type has_function(...);                                                        \
            public:                                                                                                                   \
                static constexpr bool value = std::is_same_v<decltype(has_function<InputType>(nullptr)), std::true_type>;             \
        };                                                                                                                            \
    }

// This macro is shorthand for `GENERATE_STATIC_MEMBER_FUNCTION_CHECK_TRAIT`.
// Essentially, this version of the macro generates the `trait_name` argument using the `function_name` specified.
#define GENERATE_STATIC_MEMBER_FUNCTION_CHECK(function_name, function_signature) \
    GENERATE_STATIC_MEMBER_FUNCTION_CHECK_TRAIT(_HAS_STATIC_MEMBER_FUNCTION_##function_name, function_name, function_signature)

#define GENERATED_TRAIT_VALUE(trait_name, type) \
    util::generated_impl::trait_name<type>::value

// This macro allows you to easily access the resulting value from a
// type-trait generated by `GENERATE_STATIC_MEMBER_FUNCTION_CHECK`.
#define HAS_STATIC_MEMBER_FUNCTION(type, function_name) \
    GENERATED_TRAIT_VALUE(_HAS_STATIC_MEMBER_FUNCTION_##function_name, type)

GENERATE_STATIC_MEMBER_FUNCTION_CHECK(fn, void (*)(void));

struct X
{
    // Static member; should return `true` from the generated trait.
    static void fn()
    {
        std::cout << "Hello from `X::fn` static member function.\n";
    }
};
 
struct Y
{
    // Non-static member; should return `false` from the generated trait.
    void fn()
    {
        std::cout << "Hello from `Y` non-static member function.\n";
    }
};
 
struct Z
{
    // No member named `fn`.
};

template <typename T>
void do_something()
{
    std::cout << typeid(T).name() << ": ";

    if constexpr (HAS_STATIC_MEMBER_FUNCTION(T, fn))
    {
        T::fn();
    }
    else
    {
        std::cout << "`fn` function not found.\n";
    }
}

int main()
{
    std::cout << "Does `X` have a static member function named `fn`? " << HAS_STATIC_MEMBER_FUNCTION(X, fn) << '\n';
    std::cout << "Does `Y` have a static member function named `fn`? " << HAS_STATIC_MEMBER_FUNCTION(Y, fn) << '\n';
    std::cout << "Does `Z` have a static member function named `fn`? " << HAS_STATIC_MEMBER_FUNCTION(Z, fn) << '\n';
    
    std::cout << '\n';

    std::cout << "Attempting dispatch based on whether `fn` is present...\n\n";

    do_something<X>();
    do_something<Y>();
    do_something<Z>();
}